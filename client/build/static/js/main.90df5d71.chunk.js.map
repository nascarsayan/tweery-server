{"version":3,"sources":["components/IndMap/index.js","App.js","serviceWorker.js","index.js"],"names":["MapContainer","state","ind","lat","lng","activeMarker","selectedPlace","title","showingInfoWindow","onMarkerClick","props","marker","setState","onInfoWindowClose","onMapClicked","this","points","Fragment","style","width","height","position","google","zoom","onClick","initialCenter","map","point","i","coord","place","bounding_box","coordinates","reduce","acc","nxt","parseFloat","length","name","key","window","open","url","text","Component","GoogleApiWrapper","apiKey","App","term","onSearch","a","axios","get","response","data","dateToJSON","date","local","Date","setMinutes","getMinutes","getTimezoneOffset","toJSON","slice","onDownload","jsonstr","curdate","fileDownload","JSON","stringify","Grommet","full","theme","grommet","Box","align","justify","pad","TextInput","placeholder","value","onChange","e","target","onKeyDown","Button","icon","Download","_","IndMap","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.90df5d71.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport { Map, Marker, GoogleApiWrapper } from 'google-maps-react'\n// import { Map, InfoWindow, Marker, GoogleApiWrapper } from 'google-maps-react'\n\nexport class MapContainer extends Component {\n  state = {\n    ind: {\n      lat: [6.5546079, 35.6745457],\n      lng: [68.1113787, 97.395561]\n    },\n    activeMarker: {},\n    selectedPlace: {\n      title: ''\n    },\n    showingInfoWindow: false\n  }\n  onMarkerClick = (props, marker) =>\n    this.setState({\n      activeMarker: marker,\n      selectedPlace: props,\n      showingInfoWindow: true\n    })\n\n  onInfoWindowClose = () =>\n    this.setState({\n      activeMarker: null,\n      showingInfoWindow: false\n    })\n\n  onMapClicked = () => {\n    if (this.state.showingInfoWindow)\n      this.setState({\n        activeMarker: null,\n        showingInfoWindow: false\n      })\n  }\n  render() {\n    const {\n      state: {\n        ind: {\n          lat,\n          lng\n        },\n        // activeMarker,\n        // showingInfoWindow,\n        selectedPlace: {\n          title,\n          // url\n        }\n      },\n      props: {\n        points\n      },\n      onMapClicked,\n      // onInfoWindowClose\n    } = this\n    return (\n      <React.Fragment>\n        <div>\n          {title}\n        </div>\n        <Map\n          style={{\n            width: '100%',\n            height: '90vh',\n            position: 'relative',\n          }}\n          google={this.props.google}\n          zoom={5}\n          onClick={onMapClicked}\n          initialCenter={{\n            lat: (lat[0] + lat[1]) / 2,\n            lng: (lng[0] + lng[1]) / 2,\n          }}>\n          {(points).map((point, i) => {\n            const coord = point.place.bounding_box.coordinates[0]\n            const lat = coord.reduce((acc, nxt) => parseFloat(acc) + parseFloat(nxt[1]), 0) / coord.length\n            const lng = coord.reduce((acc, nxt) => parseFloat(acc) + parseFloat(nxt[0]), 0) / coord.length\n            return (\n              <Marker\n                name={point.place.name}\n                key={`${i}`}\n                onClick={() => window.open(point.place.url, '_blank')}\n                position={{ lat, lng }}\n                title={point.text}\n              />)\n          })}\n          {/* <InfoWindow\n            marker={activeMarker}\n            onClose={onInfoWindowClose}\n            onClick={() => window.open(url, '_blank')}\n            visible={showingInfoWindow}>\n            <div>\n              {title}\n            </div>\n          </InfoWindow> */}\n        </Map>\n      </React.Fragment>\n    );\n  }\n}\n\n\n\nexport default GoogleApiWrapper({\n  apiKey: 'AIzaSyBFh8igN1Toe_7D4RrFpLouR_F64HcgHkw'\n})(MapContainer)","import React, { Component } from 'react'\nimport axios from 'axios';\nimport IndMap from './components/IndMap'\nimport { grommet } from \"grommet/themes\"\nimport { Download } from 'grommet-icons'\nimport { Grommet, TextInput, Box, Button } from 'grommet'\nimport fileDownload from 'js-file-download'\n\nclass App extends Component {\n  state = {\n    points: [],\n    term: ''\n  }\n\n  onSearch = async (term) => {\n    const response = await axios.get(`http://localhost:3002/api/query/recent?term=${term}`)\n    this.setState({ points: response.data })\n  }\n\n  dateToJSON = (date) => {\n    const local = new Date(date)\n    local.setMinutes(date.getMinutes() - date.getTimezoneOffset())\n    return local.toJSON().slice(0, 10)\n  }\n\n  onDownload = async (jsonstr) => {\n    const {\n      state: {\n        term\n      }\n    } = this\n    const curdate = this.dateToJSON(new Date())\n    fileDownload(JSON.stringify(jsonstr, null, 2), `${term}-${curdate}.json`)\n  }\n\n  render() {\n    const {\n      state: {\n        points,\n        term,\n      },\n      onSearch,\n      onDownload\n    } = this\n    return (\n      <Grommet full theme={grommet}>\n        <Box align=\"center\" justify=\"start\" pad=\"medium\">\n          <Box width=\"medium\">\n            <TextInput\n              placeholder='Search For'\n              value={term}\n              onChange={e => this.setState({ term: e.target.value })}\n              onKeyDown={e => {\n                if (e.key === 'Enter') {\n                  onSearch(term)\n                }\n              }}\n            />\n          </Box>\n          <Button\n            icon={<Download />}\n            onClick={_ => onDownload(points)}\n          />\n        </Box>\n        <Box>\n          <IndMap points={points} />\n        </Box>\n      </Grommet>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}